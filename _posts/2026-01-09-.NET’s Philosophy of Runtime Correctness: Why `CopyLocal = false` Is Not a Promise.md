---
title: "[Basics].NET’s Philosophy of Runtime Correctness: Why `CopyLocal = false` Is Not a Promise"
categories: dotnet
tags: [Basic, CSharp]
layout: single
share: false
---

When working with SDK-style .NET projects (.NET Core / .NET 5+), many developers are surprised by the following behavior:

> Even if a referenced project explicitly sets **Copy Local = false**,  
> the host project still copies **additional dependent DLLs** during build.

At first glance, this feels like a bug or a broken setting. In reality, it is **intentional behavior rooted in .NET’s design philosophy of Runtime Self-sufficiency**.

---

## The Observed Problem

Consider this setup:

**Project A** (library):
- References several external assemblies
- Sets those references to: `Copy Local = false`
- Exposes **public APIs** that use types from those assemblies

**Project B** (host / application):
- References **Project A**
- Builds successfully, but…

### Unexpected Result
During build of **Project B**:
- Project A’s output DLL is copied ✔
- **All assemblies used by Project A’s public API are also copied** ❗
- Even though Project A explicitly disabled local copying

---

## What Actually Happens During Build

The critical step is **RAR (Resolve Assembly References)**. The build system must guarantee that the final output is actually executable.

The simplified flow looks like this:  
```
Referenced Project 
	↓ 
Public API exposes external types 
	↓ 
RAR determines those assemblies are required at runtime 
	↓
Assemblies become transitive runtime dependencies 
	↓ 
Host project MUST copy them
```

A **public API acts as a runtime contract**. If a public method, property, or return value exposes a type from another assembly, the runtime **cannot function without it**. Therefore, the build system overrides your manual preference to prevent a `TypeLoadException` at runtime.  

Consequently, if you wish to prevent these files from being copied locally, you must explicitly include a snippet in your **.csproj** file to filter out specific build outputs.

```XML
<PropertyGroup>
  <MyTargetDir>C:\Your\Custom\Path\Here\</MyTargetDir>
</PropertyGroup>

<Target Name="RemoveTransitiveDlls" AfterTargets="ResolveAssemblyReferences">
  <ItemGroup>
    <ReferenceCopyLocalPaths Remove="@(ReferenceCopyLocalPaths)"
      Condition="
        $([System.Text.RegularExpressions.Regex]::IsMatch(
          '%(Identity)',
          '^$([System.Text.RegularExpressions.Regex]::Escape($(MyTargetDir)))'
        ))
      " />
  </ItemGroup>
</Target>
```

---

## The Core Philosophy: Runtime Correctness Over Local Preference

This behavior is not a flaw; it is a fundamental design principle of modern .NET. In the SDK-style project system, **Runtime Correctness > Project-level Configuration**.

.NET follows a **self-contained correctness model**:
* Build output must be **runtime-safe** by default.
* The system ensures that if a project compiles, it has all the necessary pieces to actually execute.
* Explicit settings like `CopyLocal = false` yield to **runtime necessity**.

In the older .NET Framework, the developer was responsible for the integrity of the `bin` folder. In modern .NET, the SDK takes that responsibility to ensure that **what you build is what will actually run**.

---

## Final Thoughts: The Spirit of Self-Sufficiency

Once you view this behavior through the lens of **Self-contained Runtime Integrity**, the design makes sense. .NET is not trying to ignore your local preferences—it is ensuring that your deployment isn't "broken by design".

If you want to avoid transitive copying, the solution is not to toggle settings, but to ensure that dependencies remain **internal implementation details**. Otherwise, in the .NET ecosystem:

> **The integrity of the Runtime Graph always wins.**
